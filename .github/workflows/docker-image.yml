name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_PRIVATE_KEY_BASE64: ${{ secrets.SSH_PRIVATE_KEY_BASE64 }}
  CI_REGISTRY_IMAGE: docker.io/${{ github.repository }} # Assuming Docker Hub for simplicity, adjust if using a private registry
  BE_IMAGE_NAME: docker.io/${{ github.repository }}/backend:${{ github.sha }}
  FE_IMAGE_NAME: docker.io/${{ github.repository }}/frontend:${{ github.sha }}
  REGISTRY_USER: ${{ secrets.DOCKER_USERNAME }} # GitHub's standard for Docker Hub login
  REGISTRY_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/merge-request')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Kaniko Cache
        uses: actions/cache@v4
        with:
          path: /kaniko/.cache
          key: ${{ runner.os }}-kaniko-${{ hashFiles('backend/Dockerfile', 'frontend/Dockerfile') }}
          restore-keys: |
            ${{ runner.os }}-kaniko-

      - name: Build and Push Backend Image
        uses: docker/build-push-action@v5
        with:
          context: backend
          file: backend/Dockerfile
          push: true
          tags: ${{ env.BE_IMAGE_NAME }}
          registry: ${{ env.CI_REGISTRY }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}
          # The kaniko cache and mirror logic are simplified/replaced by this action's standard caching

      - name: Build and Push Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: ${{ env.FE_IMAGE_NAME }}
          registry: ${{ env.CI_REGISTRY }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

  test:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install -r backend/src/requirements.txt

      - name: Run Pytest
        run: pytest backend/tests/

  deploy:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://${{ env.SSH_HOST }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY_BASE64 }}" | base64 -d > ~/.ssh/id_rsa
          chmod 400 ~/.ssh/id_rsa
          echo -e "Host * StrictHostKeyChecking no" > ~/.ssh/config
          ssh-keyscan -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH and Docker Compose
        env:
          PROJECT_NAME: ${{ github.event.repository.name }}
          DEPLOY_PATH: /home/${{ env.SSH_USER }}/${{ github.event.repository.name }}
        run: |
          # 1. Create remote directory and copy compose file
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p $DEPLOY_PATH"
          scp ./compose.yml ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:$DEPLOY_PATH/compose.yml

          # 2. Remote execution
          # Use CI_REGISTRY_IMAGE for the name prefix, CI_COMMIT_SHA for the tag
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'EOF'
            set -e # Exit immediately if a command exits with a non-zero status

            cd "$DEPLOY_PATH"

            # Log in to registry
            echo "$REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" --username "$REGISTRY_USER" --password-stdin

            # Substitute image names and port mapping in compose.yml
            # Note: Using sed with single quotes inside the remote shell requires careful escaping,
            # but here, single quotes in the outer shell's heredoc 'EOF' prevent local variable expansion,
            # and the GitHub env variables are expanded *before* the remote shell starts.
            # We use sed with | as a delimiter to avoid conflicts with / in image names.

            # We need to escape $ in $BE_IMAGE_NAME and $FE_IMAGE_NAME for sed
            BE_IMAGE_NAME_ESC=$(echo "$BE_IMAGE_NAME" | sed 's/\([/\$\.]\)/\\&/g')
            FE_IMAGE_NAME_ESC=$(echo "$FE_IMAGE_NAME" | sed 's/\([/\$\.]\)/\\&/g')

            sed -i 's|image: prod_backend|image: '$BE_IMAGE_NAME_ESC'|g' compose.yml
            sed -i 's|image: prod_frontend|image: '$FE_IMAGE_NAME_ESC'|g' compose.yml
            sed -i 's|- "5173:5173"|- "80:5173"|g' compose.yml

            # Pull, up, and prune
            docker compose pull
            docker compose up -d --remove-orphans
            docker system prune -af
          EOF
